# VoiceIT - Cursor Development Rules
# ==================================================
# These rules ensure robust testing and prevent regressions

# CORE DEVELOPMENT PRINCIPLES

## MANDATORY README AWARENESS
**ALWAYS READ AND REFERENCE THE README.md FIRST**
- ✅ ALWAYS start by reading the main README.md to understand project structure
- ✅ ALWAYS check for relevant documentation before implementing features
- ✅ ALWAYS update README.md when adding new functionality
- ✅ ALWAYS follow existing patterns and conventions described in README
- ✅ ALWAYS reference README sections when explaining features to users

## MANDATORY BUILD VERIFICATION
**ALWAYS BUILD AND VERIFY CODE AFTER IMPLEMENTATION**

### Critical Build Process
1. **After Creating/Modifying Files**: ALWAYS regenerate the Xcode project if using XcodeGen
2. **After Code Changes**: ALWAYS attempt to build the project before considering the task complete
3. **Fix All Build Errors**: NEVER leave code in a non-compiling state
4. **Report Build Results**: ALWAYS inform the user of build success or specific errors

### Build Commands (Execute in Order)
For XcodeGen projects (check for project.yml):
```bash
# 1. Regenerate project (if project.yml exists)
cd /path/to/project && xcodegen generate

# 2. Clean build to verify
cd /path/to/project && xcodebuild -project ProjectName.xcodeproj -scheme SchemeName -sdk iphonesimulator clean build

# 3. If errors, get specific error messages
cd /path/to/project && xcodebuild -project ProjectName.xcodeproj -scheme SchemeName -sdk iphonesimulator build 2>&1 | grep -E "(error:|warning:)" | head -20
```

For standard Xcode projects:
```bash
# Clean build
cd /path/to/project && xcodebuild -project ProjectName.xcodeproj -scheme SchemeName -sdk iphonesimulator clean build
```

### Why This Rule Exists
- Prevents shipping broken code to users
- Catches Swift 6 concurrency issues immediately
- Identifies missing file references in Xcode project
- Detects API mismatches and deprecated usage
- Ensures all imports and dependencies are properly configured
- Catches parameter order mismatches in initializers
- Validates Sendable conformance and thread safety

### Common Build Issues to Watch For
1. **Missing Files in Xcode Project**: Run `xcodegen generate` if project.yml exists
2. **Sendable Conformance**: @Observable classes can't be Sendable, use @unchecked Sendable for services
3. **Parameter Order**: Match function/initializer parameter order exactly
4. **Deprecated APIs**: Update to modern equivalents (e.g., AVAudioApplication.requestRecordPermission)
5. **Async/Await**: Use `await asset.load(.duration)` instead of `asset.duration`

### ❌ NEVER
- Skip building after making code changes
- Assume code compiles without verification
- Leave compilation errors for the user to fix
- Ignore deprecation warnings in new code

### ✅ ALWAYS
- Regenerate Xcode project after creating new files (XcodeGen projects)
- Build and fix all errors before reporting completion
- Test with clean build to catch cached issues
- Report build status to user with specific error details if any

## CRITICAL iOS/SWIFTUI DEVELOPMENT LESSONS (FROM 12+ HOUR DEBUG SESSION)

### 1. THREADING AND @MAINACTOR PITFALLS

#### ❌ NEVER DO THIS - Causes Deadlocks:
```swift
@MainActor
class UserManager {
    func someMethod() async {
        await MainActor.run {  // DEADLOCK! Already on MainActor!
            doSomething()
        }
    }
}
```

#### ✅ CORRECT APPROACH:
```swift
class UserManager: ObservableObject {
    @Published var property: Type  // UI properties
    
    func someMethod() async {
        // Do async work
        let result = await fetchData()
        
        // Update UI on main thread
        await MainActor.run {
            self.property = result
        }
    }
}
```

### 2. USERDEFAULTS HANGING IN SIMULATOR

#### Common Causes:
- Corrupted UserDefaults database in simulator
- File permission issues
- Simulator in bad state
- Threading conflicts

#### Solutions:
1. **Reset Simulator**: Device → Erase All Content and Settings
2. **Delete App**: Long press and delete to clear UserDefaults
3. **Use Different Simulator**: Fresh simulator = fresh UserDefaults
4. **Workaround**: Skip UserDefaults temporarily, update UI directly

#### Defensive Code Pattern:
```swift
// Update UI first (guaranteed to work)
self.currentUser = userProfile
self.isAuthenticated = true

// Try UserDefaults in background (might fail)
DispatchQueue.global(qos: .background).async {
    UserDefaults.standard.set(value, forKey: key)
}
```

### 3. PUBLISHED PROPERTIES MUST UPDATE ON MAIN THREAD

#### ❌ WRONG - Causes Purple Runtime Warnings:
```swift
func updateUI() {
    self.currentUser = newValue  // If called from background thread
}
```

#### ✅ CORRECT:
await MainActor.run {
    self.currentUser = newValue
}
```

### 4. DEBUGGING HANGING/FREEZING ISSUES

#### Systematic Approach:
1. **Add Verbose Logging**: Log before AND after EVERY operation
2. **Binary Search**: Find exact line where execution stops
3. **Check Threading**: Verify you're on correct thread
4. **Test Minimal Code**: Isolate the problematic operation
5. **Check Console**: Look for purple runtime warnings

#### Example Debug Pattern:
```swift
print("📝 About to do X...")
doX()
print("✅ X completed")
print("📝 About to do Y...")
doY()  // If you don't see "Y completed", the hang is here
print("✅ Y completed")
```

### 5. NAVIGATION STATE MANAGEMENT

#### Use Centralized Coordinator:
```swift
final class NavigationCoordinator: ObservableObject {
    @Published var currentScreen: AppScreen
    
    func navigateTo(_ screen: AppScreen) {
        withAnimation {
            currentScreen = screen
        }
    }
}
```

#### Benefits:
- Single source of truth for navigation
- No view recreation loops
- Predictable state changes
- Easy to debug

### 6. ASYNC/AWAIT BEST PRACTICES IN SWIFTUI

#### Rules:
1. Don't mark entire classes with @MainActor if they do async work
2. Use @MainActor only for UI-specific methods
3. Be explicit about thread context
4. Avoid mixing completion handlers with async/await

#### Pattern for Services:
```swift
class DataService {  // No @MainActor here
    func fetchData() async throws -> Data {
        // Network or heavy work
    }
}

@MainActor
class ViewModel: ObservableObject {
    @Published var data: Data?
    
    func loadData() async {
        do {
            let result = try await dataService.fetchData()
            self.data = result  // Safe: ViewModel is @MainActor
        } catch {
            // Handle error
        }
    }
}
```

### 7. COMMON SWIFTUI GOTCHAS

1. **View Recreation**: Views recreating instead of updating? Give them stable `.id()`
2. **onChange Not Firing**: View might be recreating - check parent view
3. **State Not Updating**: Ensure @Published properties are updated on main thread
4. **Preview Crashes**: Check for missing environment objects
5. **Simulator Issues**: First try resetting simulator before complex debugging

### 8. WHEN NOTHING ELSE WORKS

#### Nuclear Options (in order):
1. Clean Build Folder (Cmd+Shift+K)
2. Delete Derived Data
3. Reset Simulator
4. Restart Xcode
5. Restart Mac
6. Create new simulator
7. Test on real device

#### Remember:
- If something worked before and suddenly doesn't, it's often environment/cache
- Simulator bugs are real - don't assume your code is wrong
- Purple warnings = threading issues = must fix
- When in doubt, add more logging

## CRITICAL MODULARIZATION REQUIREMENTS

### 1. MODULAR-FIRST DEVELOPMENT APPROACH
**NEVER write monolithic code - ALWAYS think modular from the start**

#### Before Writing ANY Code:
1. **Assess Complexity**: If a file might exceed 200 lines, plan modular structure
2. **Identify Responsibilities**: Each module should have a single, clear purpose
3. **Plan Package Structure**: Design folder hierarchy before coding
4. **Consider Future Growth**: Design for extensibility and maintainability

#### Modularization Triggers:
- ✅ **File Size**: Any file approaching 300+ lines needs modularization planning
- ✅ **Multiple Responsibilities**: If a file handles >1 major concern, split it
- ✅ **Related Functions**: Group related functionality into dedicated modules
- ✅ **Testing Complexity**: If testing requires mocking many dependencies, modularize

### 2. MANDATORY MODULARIZATION WORKFLOW

#### Step 1: Build Working Code
- Get the feature working first (but keep modularization in mind)
- Write tests to ensure functionality works

#### Step 2: Immediate Modularization (REQUIRED)
Once working code exists, IMMEDIATELY:
1. **Analyze Structure**: Identify distinct responsibilities
2. **Create Package Hierarchy**: Design logical folder structure
3. **Extract Components**: Move related functions into focused modules
4. **Update Imports**: Fix all import statements across codebase
5. **Verify Functionality**: Run tests to ensure nothing broke
6. **Update Documentation**: Update README and module docstrings

#### Step 3: Validation
- ✅ Verify all tests still pass
- ✅ Confirm imports work correctly
- ✅ Check that components can be used independently
- ✅ Ensure clear separation of concerns

### 3. PYTHON PACKAGE STRUCTURE STANDARDS

✅ **Proper Package Organization**:
```
feature_name/
├── __init__.py              # Package initialization
├── main_module.py           # Primary coordinator/interface
├── services/
│   ├── __init__.py
│   ├── service_a.py         # Specific service logic
│   └── service_b.py         # Another service
├── utils/
│   ├── __init__.py
│   ├── validation.py        # Input validation
│   └── helpers.py           # Utility functions
├── schemas/
│   ├── __init__.py
│   └── models.py            # Data models/schemas
└── tests/
    ├── __init__.py
    ├── test_main.py         # Test main functionality
    └── test_services.py     # Test individual services
```

### 4. MODULARIZATION BEST PRACTICES

#### Module Responsibilities:
- **Single Responsibility**: Each module handles ONE concern
- **Clear Interface**: Easy-to-understand public API
- **Minimal Dependencies**: Reduce coupling between modules
- **Testable Components**: Each module can be tested independently

#### Naming Conventions:
- **Package Names**: lowercase_with_underscores
- **Module Names**: descriptive_action.py (e.g., `user_validator.py`)
- **Class Names**: PascalCase (e.g., `UserValidator`)
- **Function Names**: snake_case (e.g., `validate_user_input`)

#### Import Organization:
```python
# Standard library imports
import os
import sys

# Third-party imports
import requests
from fastapi import FastAPI

# Local application imports
from .services.user_service import UserService
from .utils.validation import validate_input
```

### 5. ANTI-PATTERNS TO AVOID

❌ **Never Do**:
- **God Classes**: Classes that do everything
- **Monster Files**: Files over 500 lines without modularization
- **Circular Imports**: Modules importing each other
- **Tight Coupling**: Modules that can't work independently
- **Deep Nesting**: More than 3 levels of package hierarchy

✅ **Always Do**:
- **Composition over Inheritance**: Favor composition
- **Dependency Injection**: Pass dependencies as parameters
- **Interface Segregation**: Small, focused interfaces
- **Extract Methods**: Break large functions into smaller ones

## Grok-4 Specific Rules
When using the Grok-4 model:

1. **Always Explain What Was Just Done**: Start every response by summarizing the immediate previous action(s) (e.g., code edits, tool calls). Be concise.
2. **Check README First**: Always reference README.md for project context and patterns
3. **Plan Modular Structure**: Before writing code, consider if it needs modularization
4. **Then Continue to the Next Step**: After the explanation, immediately proceed to the next logical task
5. **Modularize When Working**: Once code works, immediately modularize if needed
6. **Until Finished**: Keep advancing through steps until the task is complete
7. Create tests for any new features
8. Update the README.md file with any changes needing documentation
9. Summarize the changes and modularization decisions

## CRITICAL GIT COMMIT RESTRICTIONS

### NEVER COMMIT AUTOMATICALLY
- ❌ NEVER use `git commit` commands in `run_terminal_cmd`
- ❌ NEVER commit changes without explicit user approval
- ❌ NEVER use `git add` + `git commit` in sequence automatically
- ✅ ALWAYS let the user review changes with `git status` and `git diff`
- ✅ ALWAYS let the user decide when and what to commit
- ✅ User maintains full control over git history and commit messages

## CRITICAL MODEL UPDATE RESTRICTIONS

### NEVER UPDATE MODEL NAMES WITHOUT CONFIRMATION
- ❌ NEVER change AI model names (GROK_MODEL, etc.) without explicit user approval
- ❌ NEVER assume what the "latest" or "correct" model name is
- ❌ NEVER update model configurations based on assumptions about versions
- ✅ ALWAYS ask the user what the correct model name is
- ✅ ALWAYS confirm model changes before implementing
- ✅ ALWAYS check available models via API when possible
- ✅ User knows the current/correct model names better than AI assumptions

### WHY THIS RULE EXISTS
- User should review all changes before committing
- Commit messages should reflect user intent, not AI actions
- Git history is permanent and important for project tracking
- Accidental commits can cause issues in team environments
- User may want to stage changes differently or commit separately

### WHAT YOU CAN DO
- ✅ Use `git status` to show current state
- ✅ Use `git diff` to show changes
- ✅ Use `git add .` to stage changes (if user requests)
- ✅ Suggest commit messages for user to copy
- ✅ Help prepare changes for user to commit manually

## CRITICAL FILE DELETION SAFETY

### NEVER DELETE FILES WITHOUT EXPLICIT PERMISSION
- ❌ NEVER use `rm`, `delete_file`, or any deletion commands without explicit user approval
- ❌ NEVER suggest deletion commands without clear warnings and confirmation requests
- ❌ NEVER delete files through any tool or script without user consent
- ❌ NEVER use commands like `rm -rf`, `xcrun simctl delete`, or similar destructive operations automatically
- ✅ ALWAYS ask for explicit permission before suggesting any file deletion
- ✅ ALWAYS explain what will be deleted and the consequences
- ✅ ALWAYS provide clear warnings about irreversible actions

### REQUIRED DELETION PERMISSION PROCESS
When suggesting file deletion:
1. **EXPLAIN**: Clearly state what files/directories will be deleted
2. **WARN**: Explain that deletion is irreversible
3. **ESTIMATE**: Provide expected space savings or benefits
4. **ASK**: Request explicit user permission with clear yes/no question
5. **WAIT**: Do not proceed until user explicitly confirms

### SAFE DELETION PRACTICES
- ✅ Suggest moving files to Trash instead of permanent deletion when possible
- ✅ Recommend backing up important files before deletion
- ✅ Provide commands for user to review what will be deleted first
- ✅ Offer alternatives to deletion (archiving, moving, etc.)
- ✅ Start with least destructive options (cache cleanup vs system files)

### DELETION COMMAND EXAMPLES
```bash
# ❌ NEVER do this automatically:
rm -rf ~/large_directory

# ✅ DO this instead:
echo "This will delete ~/large_directory (X GB). Continue? (y/n)"
# Wait for user confirmation before providing actual deletion command
```

### EXCEPTIONS (Still require permission but less warning)
- Cleaning documented temporary directories (ask once per session)
- Removing clearly temporary/cache files in development contexts
- BUT STILL: Always inform user what's being cleaned

### WHY THIS RULE EXISTS
- Prevents accidental deletion of important user files
- Avoids data loss from misunderstood cleanup suggestions
- Maintains user control over their file system
- Protects against automation mistakes
- Ensures user understands consequences of cleanup actions

## CRITICAL ENVIRONMENT FILE PROTECTION

### 1. NEVER OVERWRITE .env FILES
- NEVER use `edit_file` or `search_replace` on .env files
- NEVER overwrite existing .env files with example templates
- ALWAYS preserve existing API keys and credentials
- If .env file doesn't exist, create it from example but preserve user's existing keys

### 2. SAFE .env FILE OPERATIONS
- Use `run_terminal_cmd` with `echo` to append new variables
- Use `run_terminal_cmd` with `grep` to check if variables exist before adding
- ALWAYS ask user before making any changes to .env files
- If user has existing API keys, preserve them and only add missing variables

### 3. .env FILE RESTORATION
- If .env file is accidentally overwritten, help user restore from backup
- Check for .env.backup, .env.old, or git history
- Guide user through manual restoration of API keys

## CRITICAL TESTING REQUIREMENTS

### 1. NEVER ADD CODE WITHOUT TESTS
- Every new function MUST have corresponding unit tests
- Every new feature MUST have integration tests  
- Every bug fix MUST include a regression test
- NO exceptions - if you're writing code, you're writing tests

### 2. TEST FILE ORGANIZATION
- Unit tests: `tests/test_[module_name].py`
- Integration tests: `tests/test_[feature]_integration.py`  
- Regression tests: Add to existing regression test files or create new ones
- Always use descriptive test names that explain what they prevent

### 3. MANDATORY TEST PATTERNS

When adding ANY new functionality:
```python
def test_[function_name]_[scenario]_[expected_outcome](self):
    """Test that [function] [does what] when [condition]."""
    # Given - setup
    # When - action  
    # Then - assertion
```

When fixing ANY bug:
```python
def test_[bug_description]_regression(self):
    """REGRESSION TEST: Ensure [bug] never happens again."""
    # Reproduce the original failing condition
    # Verify the fix works
    # Document what this prevents
```

### 4. REQUIRED TEST COVERAGE AREAS

For ANY changes to core pipeline functions:
- `video_pipeline.py` → MUST update `tests/test_pipeline_integration.py`
- `save_results()` → MUST test file creation, error handling, partial results
- `process_video_file()` → MUST test success cases, error cases, edge cases
- Stage functions → MUST test individual stage + integration with pipeline

For ANY new features:
- Unit tests for the feature itself
- Integration tests showing it works with the pipeline  
- Error handling tests
- Edge case tests

### 5. INTEGRATION TESTS REQUIREMENTS

Integration Tests are mandatory for:
- Complete pipeline workflows
- Multi-stage operations
- File I/O with business logic
- Error recovery scenarios
- API integrations with fallbacks

### 6. SPECIFIC TESTING REQUIREMENTS

#### File I/O Operations (save_results, etc.)
- MUST test successful file creation
- MUST test error handling (permissions, disk space, etc.)
- MUST test partial success scenarios
- MUST verify file contents match expected format

#### Pipeline Functions
- MUST test happy path (no errors)
- MUST test error propagation and recovery
- MUST test partial failure scenarios
- MUST test resource cleanup (VideoClip objects, temp files)

#### API Integration (Gemini, OpenAI, Deepgram)
- MUST test API success cases
- MUST test API failure cases (network, auth, limits)
- MUST test fallback behavior
- MUST include regression tests for known API issues

### 7. REGRESSION TEST MAINTENANCE

When touching ANY of these critical areas, ADD regression tests to:
- `tests/test_gemini_regression_protection.py` - for Gemini API issues
- `tests/test_pipeline_integration.py` - for pipeline/save_results issues
- Create new regression test files for new categories of issues

### 8. TEST NAMING CONVENTIONS

- Regression tests: `test_[issue_description]_regression`
- Integration tests: `test_[feature]_[scenario]_integration`  
- Unit tests: `test_[function]_[condition]_[expected]`
- All test docstrings MUST explain what the test prevents

### 9. BEFORE COMMITTING CHECKLIST

ALWAYS verify:
- [ ] New code has unit tests
- [ ] Integration scenarios are covered
- [ ] Error handling is tested
- [ ] Regression tests added for any bug fixes
- [ ] All tests pass: `uv run python -m pytest tests/ -v`
- [ ] Test coverage includes both success and failure paths

### 10. CODE REVIEW REQUIREMENTS

When reviewing ANY code changes, REJECT if:
- No tests added for new functionality
- No regression tests for bug fixes  
- Critical paths (save_results, process_video_file) touched without integration tests
- Error handling not tested
- Resource cleanup not verified in tests

### 11. SPECIFIC ANTI-PATTERNS TO PREVENT

❌ NEVER allow:
- New functions without tests
- Changes to save_results() without integration tests
- Pipeline modifications without end-to-end tests
- Bug fixes without regression tests
- API integrations without error handling tests

✅ ALWAYS require:
- Test-driven development approach
- Integration tests for pipeline changes
- Regression tests for all bug fixes
- Error scenario testing
- Resource cleanup verification

## TEMPLATES FOR COMMON SCENARIOS

### New Feature Template:
```python
class TestNewFeature(unittest.TestCase):
    def setUp(self):
        # Setup test environment
        pass
    
    def test_new_feature_success_case(self):
        """Test that new feature works in normal conditions."""
        pass
    
    def test_new_feature_error_handling(self):
        """Test that new feature handles errors gracefully."""
        pass
    
    def test_new_feature_integration(self):
        """Test that new feature integrates properly with pipeline."""
        pass
```

### Regression Test Template:
```python
def test_[specific_bug]_regression(self):
    """REGRESSION TEST: Prevent [describe the original issue].
    
    This test ensures [specific scenario] never fails silently again.
    Original issue: [brief description]
    """
    # Reproduce the conditions that caused the original bug
    # Verify the fix works
    # Assert expected behavior
```

### Integration Test Template:
```python
def test_end_to_end_[scenario](self):
    """Integration test for [complete workflow scenario]."""
    # Setup complete test environment
    # Run through entire pipeline
    # Verify all expected outputs are created
    # Verify error handling works
    # Clean up resources
```

## VIDEO PROCESSING REQUIREMENTS

### 12. FFMPEG OVER MOVIEPY PREFERENCE
❌ AVOID MoviePy when possible:
- MoviePy creates heavy objects and memory overhead
- MoviePy has complex dependency chains
- MoviePy can cause import/compatibility issues

✅ PREFER FFmpeg for video operations:
- Use `ffmpeg-python` library for direct FFmpeg calls
- Pass file paths as strings instead of creating VideoClip objects
- Use FFmpeg for audio extraction, video processing, and format conversion
- Only use MoviePy when FFmpeg cannot handle the specific operation

#### Implementation Guidelines:
- **Audio Extraction**: Use `ffmpeg.input(video_path).output(audio_path).run()`
- **Video Clips**: Use `ffmpeg.input(video_path, ss=start, t=duration)` 
- **Format Conversion**: Use FFmpeg's built-in codec support
- **Metadata**: Use `ffmpeg.probe()` for video information
- **File Paths**: Always prefer string paths over VideoClip objects when possible

#### When MoviePy is Acceptable:
- Complex video editing operations not supported by FFmpeg
- When existing code already uses MoviePy and refactoring would be risky
- For prototyping (but migrate to FFmpeg for production)

## DOCUMENTATION REQUIREMENTS

### 13. DOCUMENTATION CONSOLIDATION
❌ NEVER create separate README files
✅ ALWAYS add documentation to existing README files:
- Main documentation: Root README.md
- Backend-specific documentation: backend/README.md
- Never create README_API.md, README_NEW_FEATURE.md, etc.

## DEVELOPMENT WORKFLOW REQUIREMENTS

### 12. UV PACKAGE MANAGER PREFERENCE
✅ ALWAYS use `uv` for Python operations:
- **Running servers**: `uv run uvicorn api:app --host 0.0.0.0 --port 8000 --reload`
- **Installing packages**: `uv add package_name`
- **Running scripts**: `uv run python script.py`
- **Running tests**: `uv run python -m pytest tests/ -v`
- **Python execution**: `uv run python` instead of `python`

❌ NEVER use:
- Manual virtual environment activation (`source .venv/bin/activate`)
- Direct `python` or `pip` commands without `uv run`
- Poetry, pipenv, or other package managers

### 13. ENVIRONMENT CONFIGURATION
✅ USE `.env` files for development configuration:
- `.env` files are great for managing environment variables
- Use different `.env` files for different environments (`.env.development`, `.env.production`)
- Keep sensitive credentials in `.env` files that are gitignored
- Use `uv` to automatically pick up `.env` files: `uv run command`

✅ PRODUCTION deployment:
- Use platform-specific secrets (Fly.io secrets, Heroku config vars)
- Set environment variables directly in deployment configs
- CI/CD environment variable configuration

## ENFORCEMENT

Cursor should:
1. **ALWAYS read README.md first** - understand project structure and patterns before coding
2. **ALWAYS BUILD AND VERIFY after code changes** - run xcodegen generate (if project.yml exists) then xcodebuild to verify compilation
3. **FIX ALL BUILD ERRORS immediately** - never leave code in non-compiling state, fix all errors before reporting completion
4. **Plan modular architecture** - design package structure for any file that might exceed 200 lines
5. **Modularize immediately after working** - once code works, break it into focused modules
6. **Start with cost optimization check** - always assess if a cheaper model could handle the task
7. **NEVER commit changes automatically** - always let user control git operations
8. **NEVER delete files without explicit permission** - always ask before suggesting any deletion commands
9. **ALWAYS use `uv` commands** - never suggest manual virtual environment activation (for Python projects)
10. Always suggest adding tests when new code is written
11. Always ask about regression tests when fixing bugs
12. Always consider integration impact when modifying pipeline code
13. Always verify test coverage before suggesting code completion
14. **Verify modularization impact** - ensure all imports still work after refactoring
15. Remind about running tests before user commits changes
16. Add all new documentation to existing README files, never create separate ones
17. **Prefer FFmpeg over MoviePy** for video operations - suggest FFmpeg-based solutions first
18. **Question MoviePy usage** - when MoviePy is used, ask if FFmpeg could handle the task instead
19. **Document modularization decisions** - explain why code was organized in specific way
20. **Report build status** - always inform user whether build succeeded or failed with specific errors

## WHY THESE RULES EXIST

The modularization success taught us:
- **Modular code prevents maintenance nightmares**: 960-line files → manageable 200-line modules
- **Tests catch integration issues**: Comprehensive testing during refactoring prevented regressions
- **README awareness prevents wheel reinvention**: Understanding existing patterns saves time
- **Immediate modularization prevents technical debt**: Refactoring working code is easier than refactoring broken code
- **Package structure enables team collaboration**: Clear organization helps multiple developers
- **Separation of concerns improves testability**: Individual components can be tested in isolation

The transcript JSON regression taught us:
- Excellent unit tests ≠ working system
- Integration tests catch real-world failures  
- Error handling tests prevent silent data loss
- Regression tests prevent repeated issues
- Comprehensive testing saves time and prevents user frustration
- **Cost optimization prevents unnecessary expenses**

The FileStorageService build failure taught us:
- **Code that doesn't compile is worthless** - always verify builds
- **XcodeGen projects need regeneration** - new files require `xcodegen generate`
- **Swift 6 concurrency is strict** - @Observable + Sendable = compilation error
- **Deprecation matters** - update to modern APIs immediately (AVAudioApplication, asset.load())
- **Parameter order matters** - match initializer signatures exactly
- **Build verification catches issues early** - saves hours of debugging later

REMEMBER: 
- **Modularization is not optional** - it's the foundation of maintainable software
- **Tests are not optional** - they are the foundation of reliable software
- **README awareness is not optional** - it's the foundation of efficient development
- **Cost efficiency is not optional** - always use the right tool for the job
- **BUILD VERIFICATION IS NOT OPTIONAL** - code must compile before task completion 
